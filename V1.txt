import os
import tempfile
from datetime import datetime
import pandas as pd
import unicodedata
from tkinter import Tk, Frame, Label, Button, Entry, StringVar, OptionMenu, LEFT, RIGHT, BOTH, X
from tkinter import messagebox
from reportlab.lib.pagesizes import A4
from reportlab.pdfgen import canvas
from reportlab.lib.units import mm
from reportlab.lib.utils import simpleSplit
from pdf2image import convert_from_path
from PIL import Image, ImageTk

# ----------------- Configuration -----------------
EMPLOYEES_FILE = 'Data.xlsx'   # <-- change si besoin
LOGO_PATH = 'logo.png'
STAMP_PATH = 'cachetITAP.png'
OUTPUT_PDF = 'lettre_liaison.pdf'
POPPLER_PATH = None                 # chemin vers poppler si sous Windows

HOSPITAUX = {
    'Hôpital Korba': 'Rue Abou Kacem CHEBBI, 8070 KORBA NABEUL',
    'Groupement Médecine du Travail': 'Av. Hédi Nouira, 8000 Nabeul',
    'Polyclinique El Hakim': 'Km 1 Route Korba Tazarka, 8024 Korba, Nabeul Gouvernorat',
    'Polyclinique El Amen': 'Av. Hédi Nouira, Nabeul'
}

ENTREPRISE_INFO = {
    'name': 'CF MAIER ITAP',
    'address': 'Z.I El Mazraa, 8024 Tazarka, Tunisie',
    'phone': '+216 72 225 278 / +216 72 225 279',
    'fax': '+216 72 225 435'
}

# ----------------- Helpers -----------------

def remove_accents(text: str) -> str:
    """Supprime les accents pour normaliser les noms de colonnes."""
    if not isinstance(text, str):
        text = str(text)
    nfkd = unicodedata.normalize('NFKD', text)
    return ''.join([c for c in nfkd if not unicodedata.combining(c)])


def normalize_employee_columns(df: pd.DataFrame) -> pd.DataFrame:
    """Renomme automatiquement les colonnes trouvées dans le fichier employés
    pour qu'on ait au minimum : Matricule, Nom, Prénom, CIN, CNSS
    """
    mapping = {}
    for col in df.columns:
        key = remove_accents(col).strip().lower()
        if 'matric' in key:
            mapping[col] = 'Matricule'
        elif key in ('prenom', 'prénom', 'prenom_employe', 'givenname', 'firstname') or 'prenom' in key:
            mapping[col] = 'Prénom'
        elif 'nom' in key:
            mapping[col] = 'Nom'
        elif 'cin' in key or 'ident' in key:
            mapping[col] = 'CIN'
        elif 'cnss' in key or 'social' in key:
            mapping[col] = 'CNSS'
        else:
            # laisser les autres colonnes telles quelles
            pass
    df = df.rename(columns=mapping)
    # S'assurer que colonnes présentes
    for needed in ['Matricule', 'Nom', 'Prénom', 'CIN', 'CNSS']:
        if needed not in df.columns:
            df[needed] = ''
    # Normaliser espaces
    df['Matricule'] = df['Matricule'].astype(str).str.strip()
    df['Nom'] = df['Nom'].astype(str).str.strip()
    df['Prénom'] = df['Prénom'].astype(str).str.strip()
    df['CIN'] = df['CIN'].astype(str).str.strip()
    df['CNSS'] = df['CNSS'].astype(str).str.strip()
    return df


def load_employees():
    """Charge le fichier CSV / XLSX et normalise les colonnes."""
    if not os.path.exists(EMPLOYEES_FILE):
        raise FileNotFoundError(f"Fichier employés introuvable: {EMPLOYEES_FILE}")
    if EMPLOYEES_FILE.lower().endswith('.xlsx') or EMPLOYEES_FILE.lower().endswith('.xls'):
        df = pd.read_excel(EMPLOYEES_FILE, engine='openpyxl')
    else:
        df = pd.read_csv(EMPLOYEES_FILE)
    df = normalize_employee_columns(df)
    return df


def format_cin(cin):
    """Garder uniquement les chiffres et compléter à 8 chiffres."""
    if pd.isna(cin) or str(cin).strip() == '':
        return ''
    s = ''.join(ch for ch in str(cin) if ch.isdigit())
    return s.zfill(8)

# ----------------- PDF Generation -----------------

def generate_pdf(data, hospital_name, hospital_address):
    c = canvas.Canvas(OUTPUT_PDF, pagesize=A4)
    width, height = A4
    margin = 20 * mm

    # Logo
    if os.path.exists(LOGO_PATH):
        c.drawImage(LOGO_PATH, margin, height - 30*mm, width=40*mm, preserveAspectRatio=True)

    # En-tête entreprise
    c.setFont('Helvetica-Bold', 10)
    c.drawString(margin, height - 40*mm, f"Nom de l'entreprise : {ENTREPRISE_INFO['name']}")
    c.setFont('Helvetica', 10)
    c.drawString(margin, height - 45*mm, f"Adresse : {ENTREPRISE_INFO['address']}")
    c.drawString(margin, height - 50*mm, f"Télephone : {ENTREPRISE_INFO['phone']}")
    c.drawString(margin, height - 55*mm, f"Fax : {ENTREPRISE_INFO['fax']}")

    # Titres
    c.setFont('Helvetica-Bold', 16)
    c.drawCentredString(width/2, height - 70*mm, "LETTRE DE LIAISON")
    c.setFont('Helvetica-Bold', 12)
    c.drawCentredString(width/2, height - 80*mm, "ADMISSION D’UN PATIENT")

    # Date automatique
    today = datetime.now().strftime('%d/%m/%Y %H:%M:%S')
    c.setFont('Helvetica', 10)
    c.drawString(margin, height - 95*mm, f"Date : {today}")

    # Corps structuré (chaque champ sur sa ligne)
    y = height - 105*mm
    lines = [
        f"La société {ENTREPRISE_INFO['name']} demande au {hospital_name} l’admission d’un patient affilié {ENTREPRISE_INFO['name']} dans les conditions suivantes :",
        "",
        f"Hôpital : {hospital_name}",
        f"Adresse : {hospital_address}",
        f"Matricule : {data.get('Matricule','')}",
        f"Nom du patient : {data.get('Nom','')} {data.get('Prénom','')}",
        "Nationalité : Tunisienne",
        f"Numéro de la Carte d'Identité Nationale (CIN) : {data.get('CIN','')}",
        f"CNSS : {data.get('CNSS','')}",
        f"Médecin requérant : {data.get('MedecinRequerant','')}",
        f"Médecin(s) traitant(s) : {data.get('MedecinTraitant','')}",
        f"Date d'admission : {data.get('DateAdmission','')}",
        f"Type de prise en charge : {data.get('TypePriseEnCharge','')}",
        ""
    ]

    c.setFont('Helvetica', 10)
    for line in lines:
        # gérer les retours à la ligne si la ligne est longue
        wrapped = simpleSplit(line, 'Helvetica', 10, width - 2*margin)
        for wline in wrapped:
            c.drawString(margin, y, wline)
            y -= 6.5*mm

    # Paragraphe final avec saut de ligne bien structuré
    paragraph = f"Prise en charge Totale par {ENTREPRISE_INFO['name']} : La facture du {hospital_name} est à régler totalement par {ENTREPRISE_INFO['name']}."
    wrapped = simpleSplit(paragraph, 'Helvetica', 10, width - 2*margin)
    for wline in wrapped:
        c.drawString(margin, y, wline)
        y -= 6.5*mm

    # Cachet et signature
    if os.path.exists(STAMP_PATH):
        c.drawImage(STAMP_PATH, margin, 20*mm, width=40*mm, preserveAspectRatio=True)

    c.setFont('Helvetica-Bold', 10)
    c.drawRightString(width - margin, 30*mm, hospital_name)
    c.save()

# ----------------- Interface Tkinter -----------------
class App:
    def __init__(self, master):
        self.master = master
        try:
            self.df = load_employees()
        except Exception as e:
            messagebox.showerror('Erreur', str(e))
            self.df = pd.DataFrame(columns=['Matricule','Nom','Prénom','CIN','CNSS'])

        # Variables
        self.hopital_var = StringVar(value=list(HOSPITAUX.keys())[0])
        self.matricule_var = StringVar()
        self.nom_var = StringVar()
        self.prenom_var = StringVar()
        self.cin_var = StringVar()
        self.cnss_var = StringVar()
        self.medecin_r_var = StringVar()
        self.medecin_t_var = StringVar()
        self.date_var = StringVar(value=datetime.now().strftime('%d/%m/%Y %H:%M:%S'))
        self.type_var = StringVar(value='Consultation médicale')

        # Layout
        left = Frame(master)
        left.pack(side=LEFT, fill=BOTH, expand=True, padx=10, pady=10)
        right = Frame(master)
        right.pack(side=RIGHT, fill=BOTH, expand=True, padx=10, pady=10)

        Label(left, text="Hôpital :").pack()
        OptionMenu(left, self.hopital_var, *HOSPITAUX.keys()).pack(fill=X)

        # Champs du formulaire
        for label, var in [
            ("Matricule", self.matricule_var),
            ("Nom", self.nom_var),
            ("Prénom", self.prenom_var),
            ("CIN", self.cin_var),
            ("CNSS", self.cnss_var),
            ("Médecin requérant", self.medecin_r_var),
            ("Médecin(s) traitant(s)", self.medecin_t_var),
            ("Date admission (jj/mm/aaaa HH:MM:SS)", self.date_var),
            ("Type de prise en charge", self.type_var)
        ]:
            Label(left, text=label).pack(anchor='w', pady=(6,0))
            Entry(left, textvariable=var).pack(fill=X)

        Button(left, text="Rechercher par Matricule", command=self.search_by_matricule).pack(pady=8)
        Button(left, text="Rechercher par Nom+Prénom", command=self.search_by_name).pack(pady=4)
        Button(left, text="Générer PDF", command=self.generate).pack(pady=8)

        # Aperçu PDF
        Label(right, text='Aperçu PDF:').pack()
        self.preview_label = Label(right)
        self.preview_label.pack()

    # --------- Recherche et remplissage ---------
    def search_by_matricule(self):
        m = self.matricule_var.get().strip()
        if not m:
            messagebox.showinfo('Info', 'Entrez un matricule à rechercher.')
            return
        df = self.df
        row = df[df['Matricule'].astype(str).str.strip() == str(m)]
        if row.empty:
            messagebox.showinfo('Résultat', 'Aucun employé trouvé pour ce matricule.')
            return
        self.fill_fields(row.iloc[0])

    def search_by_name(self):
        nom_input = self.nom_var.get().strip()
        prenom_input = self.prenom_var.get().strip()
        df = self.df

        # Cas : l'utilisateur a saisi les deux
        if nom_input and prenom_input:
            mask = (df['Nom'].astype(str).str.lower().str.strip() == nom_input.lower()) & (
                   df['Prénom'].astype(str).str.lower().str.strip() == prenom_input.lower())
            row = df[mask]
        else:
            # Cas : seul le champ 'Nom' rempli mais il contient "Nom Prénom"
            if nom_input and ' ' in nom_input and not prenom_input:
                parts = nom_input.split()
                # essayer Nom=parts[0], Prénom=parts[1]
                if len(parts) >= 2:
                    n, p = parts[0].lower(), parts[1].lower()
                    mask = (df['Nom'].astype(str).str.lower().str.strip() == n) & (
                           df['Prénom'].astype(str).str.lower().str.strip() == p)
                    row = df[mask]
                    if row.empty:
                        # essayer l'inverse (prénom puis nom)
                        mask = (df['Nom'].astype(str).str.lower().str.strip() == parts[1].lower()) & (
                               df['Prénom'].astype(str).str.lower().str.strip() == parts[0].lower())
                        row = df[mask]
                else:
                    row = df[df['Nom'].astype(str).str.lower().str.strip() == nom_input.lower()]
            elif nom_input and not prenom_input:
                # chercher sur la colonne Nom seulement (contains pour tolérance)
                row = df[df['Nom'].astype(str).str.lower().str.strip() == nom_input.lower()]
            else:
                messagebox.showinfo('Info', 'Entrez au moins le Nom ou le Nom+Prénom pour la recherche.')
                return

        if row.empty:
            messagebox.showinfo('Résultat', 'Aucun employé trouvé pour ce Nom/Prénom.')
            return
        self.fill_fields(row.iloc[0])

    def fill_fields(self, row):
        # Défensive : convertir en str et strip
        self.matricule_var.set(str(row.get('Matricule','')).strip())
        self.nom_var.set(str(row.get('Nom','')).strip())
        self.prenom_var.set(str(row.get('Prénom','')).strip())
        self.cin_var.set(format_cin(row.get('CIN','')))
        self.cnss_var.set(str(row.get('CNSS','')).strip())
        # Mettre à jour l'aperçu (optionnel)
        self.update_preview()

    # --------- Génération & Aperçu ---------
    def generate(self):
        data = {
            'Matricule': self.matricule_var.get().strip(),
            'Nom': self.nom_var.get().strip(),
            'Prénom': self.prenom_var.get().strip(),
            'CIN': format_cin(self.cin_var.get()),
            'CNSS': self.cnss_var.get().strip(),
            'MedecinRequerant': self.medecin_r_var.get().strip(),
            'MedecinTraitant': self.medecin_t_var.get().strip(),
            'DateAdmission': self.date_var.get().strip(),
            'TypePriseEnCharge': self.type_var.get().strip()
        }
        hopital = self.hopital_var.get()
        adresse = HOSPITAUX[hopital]
        generate_pdf(data, hopital, adresse)
        messagebox.showinfo('Succès', f'PDF généré: {OUTPUT_PDF}')
        self.update_preview()

    def update_preview(self):
        try:
            kwargs = {}
            if POPPLER_PATH:
                kwargs['poppler_path'] = POPPLER_PATH
            pages = convert_from_path(OUTPUT_PDF, first_page=1, last_page=1, dpi=150, **kwargs)
            if pages:
                img = pages[0]
                img.thumbnail((400, 500))
                self.preview_image = ImageTk.PhotoImage(img)
                self.preview_label.config(image=self.preview_image)
        except Exception as e:
            self.preview_label.config(text=f"Aperçu indisponible: {e}")

# --------- Lancement ---------
if __name__ == '__main__':
    root = Tk()
    root.geometry('1000x700')
    root.title('Générateur Lettre de Liaison - CF MAIER ITAP')
    app = App(root)
    root.mainloop()
